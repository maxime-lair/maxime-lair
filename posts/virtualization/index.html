<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Virtualization" /><meta name="author" content="Maxime Lair" /><meta property="og:locale" content="en" /><meta name="description" content="In this article, we will talk about the different types of virtualization available on the market, how they are implemented and try to provide an explanation how their rise to prominence in the past 15 years. At the end, we should understand what is a virtual machine, hypervisor, container or jails and have an idea of what’s coming next." /><meta property="og:description" content="In this article, we will talk about the different types of virtualization available on the market, how they are implemented and try to provide an explanation how their rise to prominence in the past 15 years. At the end, we should understand what is a virtual machine, hypervisor, container or jails and have an idea of what’s coming next." /><link rel="canonical" href="https://maxime-lair.github.io/maxime-lair/posts/virtualization/" /><meta property="og:url" content="https://maxime-lair.github.io/maxime-lair/posts/virtualization/" /><meta property="og:site_name" content="Bin/sh" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-08T19:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Virtualization" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Maxime Lair" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Maxime Lair"},"description":"In this article, we will talk about the different types of virtualization available on the market, how they are implemented and try to provide an explanation how their rise to prominence in the past 15 years. At the end, we should understand what is a virtual machine, hypervisor, container or jails and have an idea of what’s coming next.","url":"https://maxime-lair.github.io/maxime-lair/posts/virtualization/","@type":"BlogPosting","headline":"Virtualization","dateModified":"2022-01-08T19:00:00+01:00","datePublished":"2022-01-08T19:00:00+01:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://maxime-lair.github.io/maxime-lair/posts/virtualization/"},"@context":"https://schema.org"}</script><title>Virtualization | Bin/sh</title><link rel="apple-touch-icon" sizes="180x180" href="/maxime-lair/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/maxime-lair/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/maxime-lair/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/maxime-lair/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/maxime-lair/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Bin/sh"><meta name="application-name" content="Bin/sh"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/maxime-lair/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/maxime-lair/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/maxime-lair/" alt="avatar" class="mx-auto"> <img src="/maxime-lair/assets/img/favicons/avatar.gif" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/maxime-lair/">Bin/sh</a></div><div class="site-subtitle font-italic">Have fun reading</div></div><ul class="w-100"><li class="nav-item"> <a href="/maxime-lair/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/maxime-lair/roadTo/" class="nav-link"> <i class="fa-fw fas fa-road ml-xl-3 mr-xl-3 unloaded"></i> <span>ROAD TO DEVOPS</span> </a><li class="nav-item"> <a href="/maxime-lair/bin-sh/" class="nav-link"> <i class="fa-fw fas fa-tools ml-xl-3 mr-xl-3 unloaded"></i> <span>BIN-SH</span> </a><li class="nav-item"> <a href="/maxime-lair/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/maxime-lair/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/maxime-lair/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/maxime-lair/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/maxime-lair" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/maxime-lair/"> Home </a> </span> <span>Virtualization</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Virtualization</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/maxime-lair">Maxime Lair</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-01-08 19:00:00 +0100" data-toggle="tooltip" data-placement="bottom" title="Sat, Jan 8, 2022, 7:00 PM +0100" >Jan 8, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3967 words"> <em>22 min</em> read</span></div></div></div><div class="post-content"><p>In this article, we will talk about the different types of virtualization available on the market, how they are implemented and try to provide an explanation how their rise to prominence in the past 15 years. At the end, we should understand what is a virtual machine, hypervisor, container or jails and have an idea of what’s coming next.</p><p><strong>Note</strong> I’m using a CentOS 9 Stream (released in Dec 2021) running on an ESXi 7.0.</p><h2 id="definition">Definition<a href="#definition" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Virtualization is the act of creating a virtual (as opposed to actual) version of something. It includes virtual computer hardware platforms, storage devices and computer network resources. While the term is broad, in our case It is mostly applied to a few different types, namely:</p><ul><li><strong>Hardware virtualization</strong><ul><li>Full virtualization<li>Paravirtualization</ul><li><strong>Desktop virtualization</strong><li><strong>Operating-system-level virtualization</strong>, also known as <strong>containerization</strong></ul><p>We will explore each of them, and understand their usecases and differences. There is many more types which can be applied to IT/CS, but It will be explored in other articles, to name a few (with some examples):</p><div class="table-wrapper"><table><thead><tr><th>Virtualization type<th>Example<tbody><tr><td>Application<td><em>Citrix XenApp</em><tr><td>Service<td><em>Postman</em><tr><td>Memory<td><em>AppFabric Caching Service</em><tr><td>Virtual memory<td><em>Swap + RAM</em><tr><td>Storage<td><em>disk partition</em><tr><td>Virtual file system<td><em>CBFS</em>/<em>VFS</em><tr><td>Virtual disk<td><em>.iso</em><tr><td>Data virtualization<td><em>VDFS</em><tr><td>Network<td><em>VLAN</em> / <em>vNIC</em> / <em>VPN</em></table></div><p>Before we dive in the details, we can try to explain why It rose to such popularity in the recents years. By separating resources or requests for service from the physical delivery of that service, virtualization enables owners to distribute resources across the enterprise and use infrastructure more efficiently. This has been made evident with all Cloud computing platforms such as <strong>AWS</strong>, <strong>AZURE</strong> or <strong>GCP</strong>.</p><p>The rise of the service design patterns made it all the more effective under Moore’s law, where computing power was rendered cheap, and <a href="https://www.infrapedia.com/app">Internet bandwidth exploded</a> (through fiber or 5G networks), all to have clusters outsourced.</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148470728-df6d6abd-35ae-4105-a83d-848acb7bdc87.png" alt="image" data-proofer-ignore></p><h2 id="hardware-virtualization">Hardware virtualization<a href="#hardware-virtualization" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hardware virtualization specialize in efficiently employ underused physical hardware by allowing different computers to access a shared pool of resources. There is a few components to note:</p><ul><li>The hardware layer, often called <strong>host</strong>, contains the physical server components, It can be CPU, memory, network and disk drives. It requires an x86-based system with at least one CPU<li>The <strong>hypervisor</strong> creates a virtualization layer that runs between the OS and the server hardware, and acts as a buffer between the host and the virtual machines. It isolates the virtual components from their physical counterparts<li><strong>Virtual machines</strong> are software emulations of a computing hardware environment, and provide the same functionalities of a physical computer. They are often called <em>guest machine</em> and consist of virtual hardware, guest OS and guest applications</ul><p>CPU virtualization emphasizes performance and runs directly on the processor whenever possible. The goal is to reduce the overhead when running instructions from the virtual layer compared to instructions on the hardware layer.</p><h3 id="iommu-infrastructure">IOMMU infrastructure<a href="#iommu-infrastructure" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Having a memory controller with IOMMU will speed up virtualization instructions by reducing the amount of context switch, resulting in little to no difference compared to running hardware machine. This is often advertised as <strong>Intel VT-d</strong> or <strong>AMD-Vi</strong>. IOMMU is what made it all possible. It is an unit which allows guest virtual machines to directly use hardware devices through DMA and interrupt mapping. Be careful on this, as while this is a CPU unit, It requires motherboard chipset and system firmware (BIOS or UEFI) support to be usable.</p><p>A note on <strong>SR-IOV</strong> - It is a chipset feature which allows scalability of devices on virtual platforms. In IOMMU, virtual devices are mapped directly to their physical devices for performance reasons, but It limits the number of virtual machine to your number of hardware devices. <em>SR-IOV</em> solve this by allowing splitting one PCI device to many virtual ones without performance drop via parallelized direct IO access.</p><h4 id="iommu-goal">IOMMU goal<a href="#iommu-goal" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>In a virtualization environment, the I/O operations of I/O devices of a (virtual) guest OS are translated by their hypervisor (software-based I/O address translation). It results naturally in a negative performance impact.</p><p>In an emulation model, the hypervisor needs to manipulate interaction between the guest OS and the physical hardware. It implies that the hypervisor translates device address (from device-visible <em>virtual</em> address to device-visible <em>physical</em> address and back), this overhead requires more CPU computation power, and heavy I/O greatly impacts the system performance.</p><p>The next figure illustrates it:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148468760-6532e5b8-a19d-4dd1-b5c0-c40890d3737d.png" alt="image" data-proofer-ignore></p><p>Next, we get into the <strong>pass-through</strong> model, where the hypervisor is bypassed for the interaction between the guest OS and physical device. It has the advantage of avoiding the <em>emulated device and attached driver</em>. Here, the address translation is seamless between the guest OS and the physical device.</p><p>The next figure illustrates it:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148469372-00b68542-9ace-4c2b-a1e9-c4192bd8137a.png" alt="image" data-proofer-ignore></p><p>It is made available thanks to a <strong>hardware-assisted component</strong> called <em>IOMMU</em>. And It looks more like this:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148470128-6ff475ae-6eef-42db-81ec-7aede56cb8f9.png" alt="image" data-proofer-ignore></p><p>There is two memory management units in a CPU:</p><ul><li>MMU (<em>Memory management unit</em>), to translate <em>CPU-visible virtual address</em> &lt;-&gt; <em>physical address</em><li>IOMMU (<em>Input output memory management unit</em>), to translate <em>device-visible virtual address</em> &lt;-&gt; <em>physical address</em></ul><p>In order to provide this feature, <em>IOMMU</em> provides two functionalities, DMA remapping and interrupt remapping.</p><h4 id="iommu-dma-remapping">IOMMU DMA remapping<a href="#iommu-dma-remapping" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>In order to understand how <em>DMA</em> works, and why It is so effective, we need to do a recap of how memory works in our system.</p><p>Physical memory is divided into discrete units called <em>pages</em>. Much of the system’s internal handling of memory is done on a per-page basis. Page size varies, but usually use 4kB pages.</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148575500-2ffbb7c7-d2b9-4e55-83be-0c2d718df0a9.png" alt="image" data-proofer-ignore></p><p>This means that If you look at a memory address, virtual or physical, It is divisible into a page number and an offset within the page. One example will explain it more easily how paging works:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148585428-5172901e-5f9c-454c-9cec-798bc401493b.png" alt="image" data-proofer-ignore></p><p>One note on <em>TLB</em>, since page tables are hold in memory, every data/instruction acccess requires 2 memory accesses (One for virtual address, one for physical address), and memory accesses are much slower than instruction execution in CPU. To accelerate the translation mechanism, a small fast-lookup hardware cache is added close to CPU, and this is called the <em>Translation look-aside buffer</em> or <strong>TLB</strong>, It contains the most common of the page-table entries. In the screenshot below, you will notice It is noted <em>Huge</em>, simply because 4KB is often not enough in today’s context, so we created bigger pages.</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148585868-435cee8a-47c4-459f-a58a-f6a2019a7ab6.png" alt="image" data-proofer-ignore></p><p>Now that we know how memory is translated from virtual to physical realm, let’s dive into the <strong>DMA</strong> topic. <strong>DMA</strong>, or direct memory access, is the hardware mechanism that allows peripheral components to transfer their I/O data directly to and from main memory without the need to involve the system processor. A great deal of computational overhead is eliminated as the use of this mechanism can greatly increase throughput to and from a device.</p><p>Without DMA, on any I/O operations, the CPU is typically fully occupied for the entire duration of the read and write operation, and is thus unavailable to perform other work. With DMA, the CPU first initiates the transfer then It does other operations while the transfer is in progress, and It finally receives an interrupt from the DMA controller when the operation is done. <strong>DMA</strong> does not only exist on CPU, but on many hardware systems such as disk drive controllers, graphics cards, network cards and sound cards.</p><p>On PCI architecture, any PCI device can request control of the bus and request to read from and write to system memory. One issue is often the size of the address bus, as It can be unable to address memory above a certain line, and that’s where the IOMMU comes into play with its previously seen address translation mechanism.</p><p>The idea of IOMMU DMA remapping is the same as the MMU for address translation.</p><h4 id="iommu-interrupt-remapping">IOMMU interrupt remapping<a href="#iommu-interrupt-remapping" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>An <strong>interrupt</strong> is a response by the CPU to an event that needs attention from the software. It is commonly used by hardware devices to indicate electronic or physical state changes that require time-sensitive attention.</p><p>A <strong>MSI</strong>, or message signalled interrupts, are an alternative in-band method of signalling an interrupt. It allows devices to save up on an interrupt line (pin), as It uses in-band signalling to exchange special messages that indicates interrupts through the main data path. Fewer pins makes for a simpler, cheaper and more reliable connector. PCI Express only uses <em>MSI</em> for example as It presents a slight performance advantage.</p><p>Device can trigger interrupt by performing a DMA to dedicated memory range (<em>0xFEE00000 - 0xFEEFFFFF on x86</em>). This means a virtual machine can program device to perform arbitrary interrupts. Without it, IOMMU cannot distinguish between genuine <em>MSI</em> from the device and a DMA pretending to be an interrupt.</p><h3 id="full-virtualization">Full virtualization<a href="#full-virtualization" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Now that we understand how IOMMU came into play to enhance virtual machine performance, let’s check some relevant approach to virtualization technology.</p><p>In <strong>Full virtualization</strong>, hardware is emulated to the extent that unmodified guest OS can run on the virtualization platform. Normally, this means that various hardware devices are emulated. Such virtualization platform attempts to run as many instructions on the native CPU as possible (which is a lot faster than CPU emulation). Many of these platforms require CPU extensions to assist virtualization such as an IOMMU.</p><p>The hardware architecture is completely simulated, and the guest OS is unaware that It is in a virtualized environment, and therefore hardware is virtualized by the host OS so that the guest can issue commands to what It thinks is actual hardware. However, these are just simulated hardware devices created by the host, and the hypervisor translates all OS calls. It isolates VMs from the host OS and one another, enabling total portability of VMs between hosts regardless of underlying hardware.</p><p>It is often called <em>type-1 bare-metal</em> virtualization. It offers the best isolation and security for virtual machines. A few products to name them: KVM, ESXi, Hyper-V or Xen.</p><h3 id="paravirtualization">Paravirtualization<a href="#paravirtualization" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>OS Assisted Virtualization</strong> is another approach to virtualization technology, where the guest OS is ported to the hypervisor, a layer sitting between the hardware and virtualized systems. Since It doesn’t require full device emulation or dynamic recompiling to catch privileged instructions, It is usually performing at a near-native speed.</p><p>While the value proposition of paravirtualization is in lower virtualization overhead, its compatibility and portability is poor.</p><p>It is often called <em>type-2</em> virtualization. A few products use this technology, like QEMU, Xen, VirtualBox or VMWare workstation.</p><h2 id="desktop-virtualization">Desktop virtualization<a href="#desktop-virtualization" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>While not as popular as full-virtualization, <strong>desktop virtualization</strong> is a method of simulating a user workstation so It can be accessed from a remotely connected device. By abstracting the user desktop in this way, organizations can allow users to work from virtually anywhere with a network connecting to access enterprise resources without regard to the device or operating system employed by the remote user. It skyrocketed to popularity during the COVID pandemic and all the work-from-home habits.</p><p>Since the user devices is basically a display, keyboard and mouse, a lost or stolen device presents a reduced risk to the organization. All user data and programs exist in the desktop virtualization server and not on client devices.</p><p>There is three types of desktop virtualization:</p><ul><li>Virtual desktop infrastructure (VDI) - either on-premises or in the cloud, It manages the desktop virtualization server as they would any other application server<li>Remote desktop services (RDS) - runs a limited number of virtualized applications which are streamed to the local device, offers a higher density of users per VM<li>Desktop-as-a-service (DaaS) - shifts the burden of providing desktop virtualization to service providers, depends on IT expenses/needs</ul><h2 id="containerization">Containerization<a href="#containerization" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>Containers and virtual machines have similar resource isolation and allocation benefits, but function differently because containers virtualize the operating system instead of hardware. This makes containers more portable and efficient. They can be considered a lighter-weight, more agile way of handling virtualization since they don’t use a hypervisor.</p><p>To re-use the previous figure, containers run like this:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148616045-1f0aad36-6c98-4a2d-ae69-fcd2a8cd887a.png" alt="image" data-proofer-ignore></p><p>Containers are an abstraction at the application layer that packages code and dependencies together. They take up less space than VMs (typically tens of MBs in size) and can handle more applications. It is all from the benefits of reducing the operating system redundancy/overhead included in VM. Containerization packages together everything needed to run a single application (along with runtime libraries they need to run). The container includes all the code, its dependencies and even the operating system itself. This enables applications to run almost anywhere.</p><p>Containers use a form of operating system virtualization, but they leverage features of the host operating system to isolate processes and control their access to physical devices. While the technology has been around for decades, the introduction of Docker in 2013 changed the common consensus.</p><p>Containers are made available through a few Kernel features, mainly: | Kernel features | Description | | — | — | | Kernel namespaces | It wraps a global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource | | Seccomp | Provides application sandboxing mechanism. It allows one to configure actions to take for matched syscalls | | CGroups (control groups) | Used to restrict resource usage for a container and handle device access. It restrict cpu, memory, IO, pids, network and RDMA resources for the container |</p><p>There is a few containers projects to note:</p><ul><li>LXC (System containers without the overhead of running a kernel) - also called <strong>Linux containers</strong><li>Docker containers (cross-platform, standalone executable packages)<li>Snaps (Single machine deployment for fleet of IoT devices)<li>Tanzu (VMWare container solution)</ul><p>It is interesting to note that, while Docker has been synonymous with containers from the beginning, It might change in the coming years. Kubernetes announced last year that they will shift from Docker Runtime to the <em>Container Runtime Interface</em> as defined by the <em>Open Container Initiative</em>, which supports a broader set of container runtimes with smooth interoperability. It will open the way for Docker competitors in the future (or not).</p><h3 id="container-manager">Container manager<a href="#container-manager" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>First, check out this <strong>containerd</strong> architecture:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148648926-50dadb1a-71fd-46c1-b1b1-79d1d534c325.png" alt="image(2)" data-proofer-ignore></p><p>It gives out a nice top-level overview of how a system (whether It’s Windows or Linux) interact with its containers (whether they are docker, from cloud providers, or from k8s).</p><p>Why am I talking about <strong>containerd</strong> ? Docker (or containers) is a cluster of various utilities doing a wide variety of things hidden under the hood. Simply typing <code class="language-plaintext highlighter-rouge">docker run webserver</code> is great for users, but bad to understand its inner architecture. A great article about this is <a href="https://iximiuz.com/en/posts/container-learning-path/">here</a> and this part will simply reflect what I learnt from it.</p><p><strong>containerd</strong> is meant to be a simple daemon that will manage your containers and shims so they can run on any system. This manager will be the sticking glue between all your containers and the underlying system. It focuses on handling multiple containers so they can co-exist happily. It will handle all the boring part you don’t think of, like :</p><ul><li>Image push and pull support<li>Interfaces creation, modification and deletion<li>Management of network namespaces containers to join existing ones.<li>Storing container logs and snapshots<li>Support of container runtime and lifecycle</ul><p>Picture an apartment building. The hardware and system could be considered the ground, where utilities such as electricity (CPU), water (Storage) and heating (RAM) comes from. The building is the container manager, allowing each unit to co-exist by appointing each resource. Each apartment is the container runtime, that possess its own layout (configuration), and host a tenant. The container is this tenant who will use the available resource to conduct its lifecycle.</p><p>Most interactions with the Linux and Windows container feature sets are handled a container runtime, often via <strong>runc</strong> and/or OS-specific libraries.</p><h3 id="container-runtime">Container runtime<a href="#container-runtime" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Also called <strong>OCI runtime</strong>, there is a <a href="https://github.com/opencontainers/runtime-spec/blob/main/spec.md">specification for it</a> to specify the configuration, execution environment and lifecycle of a container.</p><p>For example, In each container, to name a few specification:</p><ul><li>In the filesystem, the following directory should be available: <em>/proc /sys /dev/pts /dev/shm</em><li>Following devices should be supplied: <em>/dev/null /dev/zero /dev/full /dev/random /dev/tty</em><li>Possess a status which may be : <em>creating created running stopped</em><li>Run through the following lifecycle: <em>Create -&gt; createRuntime -&gt; createContainer -&gt; startContainer -&gt; delete -&gt; poststop</em></ul><p>A container runtime can be considered the client part that will interact with its container manager. To start a containerized process, It happens in two steps: we create the container, then we run the process inside it. To create the container, we need to create namespaces (to isolate it from others), configure cgroups (to limit its ressource usage), etc. That’s what the <strong>container runtime</strong> will do. It knows how to create such boxes and how to interact with them since he created it.</p><p>Some folks also call this brick : <em>low-level container runtimes</em> since they only handle container execution. <em>High-level container runtimes</em> would handle image format/management/sharing like <em>containerd</em> does, but It is just confusing, so I prefer to separate them into manager and runtime. It is difficult to name them on high/low scale, because <strong>docker</strong> runs <strong>containerd</strong> which runs <strong>runc</strong>, add a container orchestration tool on top of it, and you are stuck in a maze of naming conventions.</p><p>You can even add programs that will stand in-between the <em>container runtime</em> and the <em>container manager</em>, they are called <em>shim</em>.</p><p>An architecture top-level overview (correct me If I’m wrong, It’s difficult to place everything correctly.</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148654440-4126b153-2134-407c-9ba1-5d8e41fadf31.png" alt="image" data-proofer-ignore></p><h3 id="linux-containers">Linux containers<a href="#linux-containers" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><blockquote><p>A container is an isolated (namespaces) and restricted (cgroups, capabilities, seccomp) process.</p></blockquote><p>This phrase recaps what we learned of containers so far, but It is not necessarily true. In theory, they are an isolated and restricted <strong>environments</strong> to run on or many processes inside. This means projects like <a href="https://katacontainers.io/">Kata</a> implements container without using namespaces or cgroups but full-fledged VMs and be used by Kubernetes for example.</p><p>Here, we will focus on the most popular kind of containers, which are Linux containers. Here we could use <em>LXC</em> to illustrate it, but let’s not forget that It is a set of user-land utilities, we can just try to use kernel features instead to reproduce it (not as well of course).</p><p>Let’s create a cgroup and launch an application inside. Since we will be using kernel features, I will use <code class="language-plaintext highlighter-rouge">root</code> user for simplification.</p><p>Let’s define what I want to run: <code class="language-plaintext highlighter-rouge">&lt;/dev/zero head -c 6G | tail</code> - It will fill 6G of RAM on the system</p><p>I’m using cgroups v2 for this, be sure to check what your kernel version has with:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148658579-8556d38c-4372-4d6a-9f62-d40da09ac3ec.png" alt="image" data-proofer-ignore></p><p>The following script took me a few hours, as I had to <em>realllyy</em> read the kernel documentation on <strong>cgroups v2</strong>. Main issue was the <a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#no-internal-process-constraint"><em>No internal Process Constraint</em></a> which make it so when you want to create a new cgroup and switch process inside it, you have to start from the root cgroup, because starting from any other cgroup requires you to switch all your running processes into the newly created one before doing anything (like adding memory control onto its <em>subtree_control</em> file).</p><p>The script switch your shell into the root cgroup, run the command, switch the process into our new cgroup, limits RAM to 2G let it run for a few seconds (even though It should go up to 6G), you will notice how the memory will not go higher than 2G and will slowly start to fill in the swap space before we end it. It then re-switch back to the original cgroup. It’s not perfect of course, feel free to comment on it.</p><p>The code :</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre><td class="rouge-code"><pre><span class="c">#!/bin/sh</span>
<span class="c">## ASSUMES CGROUPSv2</span>

<span class="c"># Store current cgroup</span>
<span class="nv">shell_pid</span><span class="o">=</span><span class="nv">$$</span>
<span class="nv">stored_cgroup</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">cut</span> <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f3</span> <span class="s2">"/proc/</span><span class="nv">$shell_pid</span><span class="s2">/cgroup"</span><span class="si">)</span><span class="s2">"</span>
<span class="nv">switched_cgroup</span><span class="o">=</span><span class="nb">false</span>

<span class="c"># if we are not already inside / cgroup, switch us</span>
<span class="k">if</span> <span class="o">!</span> <span class="nb">grep</span> <span class="s2">"</span><span class="se">\b</span><span class="nv">$shell_pid</span><span class="se">\b</span><span class="s2">"</span> <span class="s2">"/sys/fs/cgroup/cgroup.procs"</span> <span class="o">&gt;</span> /dev/null<span class="p">;</span> <span class="k">then
        </span><span class="nb">printf</span> <span class="s2">"[I] Switching shell from %s cgroup to root cgroup</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$stored_cgroup</span><span class="s2">"</span>
        <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$shell_pid</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"/sys/fs/cgroup/cgroup.procs"</span>
        <span class="nv">switched_cgroup</span><span class="o">=</span><span class="nb">true
</span><span class="k">else
        </span><span class="nb">printf</span> <span class="s2">"[I] Already in root cgroup</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">fi

</span><span class="nv">cgroup_name</span><span class="o">=</span><span class="s2">"cg_test"</span>
<span class="nv">cgroup_dir</span><span class="o">=</span><span class="s2">"/sys/fs/cgroup/</span><span class="nv">$cgroup_name</span><span class="s2">"</span>

<span class="nv">byte_memory_input</span><span class="o">=</span>6442450944 <span class="c"># 6 GB</span>
<span class="nv">byte_memory_limit</span><span class="o">=</span>2147483648 <span class="c"># 2 GB</span>

<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="nv">$cgroup_dir</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">mkdir</span> <span class="nv">$cgroup_dir</span>
<span class="k">else
        </span><span class="nb">printf</span> <span class="s2">"[I] %s already exist</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">"</span>
<span class="k">fi</span>

<span class="c"># Specify we want memory</span>
<span class="k">if</span> <span class="o">[</span> <span class="si">$(</span><span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"memory"</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/../cgroup.controllers"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then
        if</span> <span class="o">[</span> <span class="o">!</span> <span class="si">$(</span><span class="nb">grep</span> <span class="nt">-i</span> <span class="s2">"memory"</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/../cgroup.subtree_control"</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then
                </span><span class="nb">printf</span> <span class="s2">"[E] Missing memory in subtree parent control cgroup</span><span class="se">\n</span><span class="s2">"</span>
                <span class="nb">exit </span>1
        <span class="k">fi
        </span><span class="nb">printf</span> <span class="s2">"[I] Memory is available on parent cgroups, we can add limit on our cgroup</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">else
        </span><span class="nb">printf</span> <span class="s2">"[E] Memory unavailable on cgroups, check parent available resources in </span><span class="nv">$cgroup_dir</span><span class="s2">, exiting..</span><span class="se">\n</span><span class="s2">"</span>
        <span class="nb">exit </span>1
<span class="k">fi</span>
<span class="c">## BE CAREFUL TO NOT ADD ANYTHING INTO OUR NEWLY CREATED CGROUP SUBTREE_CONTROL</span>
<span class="c">## See https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#no-internal-process-constraint</span>
<span class="c">## It makes it impossible to add any process to our cgroup, since It stops being a leaf</span>

<span class="c"># Add our memory limit to the cgroup</span>
<span class="c"># memory.high is the memory usage throttle limit</span>
<span class="c"># memory.max is the memory usage hard limit, going beyond invokes OOM grimreaper</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/memory.high"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">printf</span> <span class="s2">"[I] Adding memory limit of %s to our cgroup</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$byte_memory_limit</span><span class="s2">"</span>
        <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$byte_memory_limit</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/memory.max"</span>
<span class="k">else
        </span><span class="nb">printf</span> <span class="s2">"[E] Missing %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/memory.max"</span>
        <span class="nb">printf</span> <span class="s2">"[E] Unable to add memory limit, exiting..</span><span class="se">\n</span><span class="s2">"</span>
        <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Now that our cgroup is created with a memory limit</span>
<span class="c"># We need to execute our program in its namespace and add its PID to our cgroups</span>
&lt;/dev/zero <span class="nb">head</span> <span class="nt">-c</span> <span class="nv">$byte_memory_input</span> | <span class="nb">tail</span> &amp;

<span class="nv">process_pid</span><span class="o">=</span><span class="nv">$!</span>

<span class="nb">printf</span> <span class="s2">"[I] Created memory command at %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$process_pid</span><span class="s2">"</span>
<span class="nb">printf</span> <span class="s2">"[I] Currently executing in cgroup %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cut</span> <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f3</span> <span class="s2">"/proc/</span><span class="nv">$process_pid</span><span class="s2">/cgroup"</span><span class="si">)</span><span class="s2">"</span>
<span class="nb">printf</span> <span class="s2">"[I] Adding PID %s to %s/cgroup.procs</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$process_pid</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">"</span>
<span class="nb">printf</span> <span class="s2">"[I] Switching process to our new cgroup %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$cgroup_name</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"</span><span class="nv">$process_pid</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> <span class="s2">"</span><span class="nv">$cgroup_dir</span><span class="s2">/cgroup.procs"</span>

<span class="c">#</span>
<span class="c"># Sleep for a bit, not necessary but better to read what's going on</span>
<span class="nb">printf</span> <span class="s2">"[I] Going to sleep while you read this</span><span class="se">\n</span><span class="s2">"</span>
<span class="nb">sleep </span>15
<span class="nb">printf</span> <span class="s2">"[I] Killing memory process as test is over</span><span class="se">\n</span><span class="s2">"</span>
<span class="nb">kill</span> <span class="nt">-9</span> <span class="s2">"</span><span class="nv">$process_pid</span><span class="s2">"</span>
<span class="nb">printf</span> <span class="s2">"[I] Kill successfull, exiting soon</span><span class="se">\n</span><span class="s2">"</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$switched_cgroup</span><span class="s2">"</span> <span class="o">=</span> <span class="nb">true</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">printf</span> <span class="s2">"[I] Switching back to original cgroup %s</span><span class="se">\n</span><span class="s2">"</span> 
        <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$shell_pid</span><span class="s2">"</span> <span class="o">&gt;</span> <span class="s2">"/sys/fs/cgroup</span><span class="nv">$stored_cgroup</span><span class="s2">/cgroup.procs"</span>
        <span class="nb">printf</span> <span class="s2">"[I] Now running shell in cgroup: %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cut</span> <span class="nt">-d</span><span class="s2">":"</span> <span class="nt">-f3</span> <span class="s2">"/proc/</span><span class="nv">$shell_pid</span><span class="s2">/cgroup"</span><span class="si">)</span><span class="s2">"</span>
<span class="k">else
        </span><span class="nb">printf</span> <span class="s2">"[I] We were already in root cgroup, just exiting without switching</span><span class="se">\n</span><span class="s2">"</span>
<span class="k">fi

</span><span class="nb">exit </span>0

</pre></table></code></div></div><p>The result: <img data-src="https://user-images.githubusercontent.com/72258375/148699324-a3dec693-9d28-4d4a-ae8c-0d2a855c15bd.gif" alt="cgroup" data-proofer-ignore></p><p>Feel free to add namespaces on top of it, use <code class="language-plaintext highlighter-rouge">unshare</code> command to add it</p><h3 id="the-next-step">The next step<a href="#the-next-step" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>The technology is still very new, as demonstrated with the google trends of Docker and K8:</p><p><img data-src="https://user-images.githubusercontent.com/72258375/148643178-ccedc223-156e-434b-abb1-96c74d454595.png" alt="image(1)" data-proofer-ignore></p><p>There is still many work to do in order to ensure containers monitoring, provisionning and orchestration. They are indeniably the way we will package applications in the future, as It is much more adaptable to a Cloud environment where hardware requires to be elastic to answer a growing organization needs.</p><h2 id="conclusion">Conclusion<a href="#conclusion" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>This concludes the introduction to virtualization as a concept. While I did not dive into the different linux technologies such as QEMU or Virt-lib, I was much more interested in understanding how IOMMU was working at the hardware level. I tried to avoid including too many details, and stayed with a top-level overview of each concepts. It’s a bit difficult to understand how they work architecturally, as many articles focus more on the code structure, or options. I’m happy with the page translation drawing I did, as It was not something clear to me for a long time. I hope It helped into understanding how virtualization is used, and how It will continue to evolve over the next decade.</p><blockquote><p>Credits</p><p>https://www.citrix.com/fr-fr/solutions/vdi-and-daas/what-is-hardware-virtualization.html</p><p>https://en.wikipedia.org/wiki/X86<em>virtualization#I/O_MMU_virtualization</em>(AMD-Vi_and_Intel_VT-d)</p><p>https://lenovopress.com/lp1467.pdf</p><p>https://www.cs.cornell.edu/courses/cs4410/2016su/slides/lecture11.pdf</p><p>https://www.oreilly.com/library/view/linux-device-drivers/0596005903/ch15.html</p><p>https://www.kernel.org/doc/html/latest/core-api/dma-api-howto.html</p><p>https://www.infrapedia.com/app</p><p>https://ubuntu.com/blog/what-is-virtualisation-the-basics</p><p>https://www.docker.com</p><p>https://containerd.io</p><p>https://www.youtube.com/watch?v=sK5i-N34im8 // cgroups,namespaces and beyond: what are containers made from ? By J. Petazzoni</p><p>https://jvns.ca/blog/2016/10/10/what-even-is-a-container/</p><p>https://iximiuz.com</p><p>http://slides.com/chrisdown/avoiding-bash-pitfalls-and-code-smells</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/maxime-lair/categories/roadto/'>RoadTo</a>, <a href='/maxime-lair/categories/os-concepts/'>OS Concepts</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/maxime-lair/tags/linux/" class="post-tag no-text-decoration" >linux</a> <a href="/maxime-lair/tags/virtualization/" class="post-tag no-text-decoration" >virtualization</a> <a href="/maxime-lair/tags/iommu/" class="post-tag no-text-decoration" >iommu</a> <a href="/maxime-lair/tags/container/" class="post-tag no-text-decoration" >container</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Virtualization - Bin/sh&url=https://maxime-lair.github.io/maxime-lair/posts/virtualization/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recent Update</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/maxime-lair/posts/sockets/">Sockets</a><li><a href="/maxime-lair/posts/networking_concepts/">Networking concepts</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/maxime-lair/tags/linux/">linux</a> <a class="post-tag" href="/maxime-lair/tags/bash/">bash</a> <a class="post-tag" href="/maxime-lair/tags/initd/">initd</a> <a class="post-tag" href="/maxime-lair/tags/network/">network</a> <a class="post-tag" href="/maxime-lair/tags/bus/">bus</a> <a class="post-tag" href="/maxime-lair/tags/cadvisor/">cadvisor</a> <a class="post-tag" href="/maxime-lair/tags/concurrency/">concurrency</a> <a class="post-tag" href="/maxime-lair/tags/container/">container</a> <a class="post-tag" href="/maxime-lair/tags/device/">device</a> <a class="post-tag" href="/maxime-lair/tags/docker/">docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/maxime-lair/posts/memory_and_storage/"><div class="card-body"> <em class="timeago small" date="2022-01-03 19:00:00 +0100" >Jan 3, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Memory and storage</h3><div class="text-muted small"><p> In this article, we will take a look at how memory and storage interact in Linux, the different technology available, and their perks and defaults Note: Im running a CentOS9 Stream in this article...</p></div></div></a></div><div class="card"> <a href="/maxime-lair/posts/io_management/"><div class="card-body"> <em class="timeago small" date="2022-01-04 19:00:00 +0100" >Jan 4, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>IO management</h3><div class="text-muted small"><p> In/Out management on Linux allows us to understand how data flows in Linux, from information coming from the network card, to the hard-drive, passing by CPU, RAM or others devices. All systems wil...</p></div></div></a></div><div class="card"> <a href="/maxime-lair/posts/service_management/"><div class="card-body"> <em class="timeago small" date="2022-01-05 19:00:00 +0100" >Jan 5, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Service management</h3><div class="text-muted small"><p> In this article, we will take a look at how service management is used in Linux, first by defining it, understanding its behavior and configuration, and some useful commands. Note: Im running a Ce...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/maxime-lair/posts/posix_basics/" class="btn btn-outline-primary" prompt="Older"><p>Posix basics</p></a> <a href="/maxime-lair/posts/threads_and_concurrency/" class="btn btn-outline-primary" prompt="Newer"><p>Threads and concurrency</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/maxime-lair">Maxime Lair</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/maxime-lair/tags/linux/">linux</a> <a class="post-tag" href="/maxime-lair/tags/bash/">bash</a> <a class="post-tag" href="/maxime-lair/tags/initd/">initd</a> <a class="post-tag" href="/maxime-lair/tags/network/">network</a> <a class="post-tag" href="/maxime-lair/tags/bus/">bus</a> <a class="post-tag" href="/maxime-lair/tags/cadvisor/">cadvisor</a> <a class="post-tag" href="/maxime-lair/tags/concurrency/">concurrency</a> <a class="post-tag" href="/maxime-lair/tags/container/">container</a> <a class="post-tag" href="/maxime-lair/tags/device/">device</a> <a class="post-tag" href="/maxime-lair/tags/docker/">docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[mode=dark]").length > 0 || ($("html[mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/maxime-lair/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/maxime-lair/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/maxime-lair/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
